; Дериктива компилятора указывающая, что
; Регистр CS будет указывать на сегмент кода
; Регистр DX - на сегмент данных
; Регистр SS - на сегмент стека
assume  cs:code,ds:data, ss:stk

; Сегмент данных
data segment
	mas1    dw  5 dup (?) ;Первый массив чисел
	mas2    dw  5 dup (?) ;Второй массив чисел
	mes1    db  0ah,0dh,'Сумма: ','$' 			;Начало для строки с суммой
	mes2    db  0ah,0dh,'Разность: ','$'		;Начало для строки с разностью
	mes3    db  0ah,0dh,'Произведение: ','$' 	;Начало для строки с суммой
	mes4    db  0ah,0dh,'Частное: ','$'			;Начало для строки с частным
	e       dw  9h 		;Текущий элемент второго массива
	i       dw  1h 		;Текущий элемент первого массива
	tmp     db  0  		;Временное хранилище
	abz     dw  ' ','$' ;Переход на новую строку
data ends
	
; Сегмент стека
stk segment stack 'stack'
    db  256 dup('*') ;Выделяем 256 байт
stk ends  

; Сегмент кода
code segment 

; Процедура для заполнения массивов числами
prep proc near
    mov i,1h ;Делаем текущим первым элементом первого массива единицу
    mov e,9h ;Делаем текущим первым элементом второго массива число 9
	; 2 строки для подготовки данных
    mov ax,data 
    mov ds,ax      
    xor ax,ax ; Обнуление регистра AX
    xor bx,bx ; Обнуление регистра BX
    mov SI,0  ; Индекс текущего элемента массива
    mov CX,5  ; Число элементов в обоих массивах
;Метка для перехода
go:
    mov bx,i 		; Записываем в регистр BX текущее готовое число
    mov mas1[si],bx ; А из регистра BX переносим это число на i-ю позицию первого массива
    mov ax,e 		; Записываем в регистр AX текущее готовое число
    mov mas2[si],ax ; А из регистра BX переносим это число на i-ю позицию второго массива
    inc i 			; Уыеличиваем текущее число (след. элемент) для первого массива на 1
	; А вот для второго массива будет увиличивать числа на 2
    inc e
    inc e
	; Переходим к обработке следующей пары элементов двух массивов
    inc si
    inc si
; Пока SI (текущий индекс) меньше чем CX (Размер массивов), переходим к метке go
LOOP go 
    ret ; Возвращаемся из фукнции 

; Процедура для суммирования элементов двух массивов с одинаковыми индексами
prep endp
add_proc proc near
    mov si,0 ; Индекс текущего элемента массива
    mov cx,5 ; Число элементов в обоих массивах
;Метка для перехода
sum:
    mov bx,mas1[si] ; Переносим текущий элемент первого массива в регистр BX
    mov ax,mas2[si] ; Переносим текущий элемент второго массива в регистр AX
    add ax,bx 		; Запишем в регистр AX сумму регистров AX и BX, то есть, текущей пары элементов
    mov mas1[si],ax ; Записываем получившуюся сумму текущих элементов на место текущего элемента первого массива
    ; Переходим к нахождению суммы следующей пары
	inc si
    inc si
; Пока SI (текущий индекс) меньше чем CX (Размер массивов), переходим к метке sum
loop sum
    ret ; Возвращаемся из фукнции 
add_proc endp

; Процедура для вычитания элементов двух массивов с одинаковыми индексами
sub_proc proc near
	mov si,0 ; Индекс текущего элемента массива
	mov cx,5 ; Число элементов в обоих массивах
;Метка для перехода
label_sub:
	mov bx,mas1[si] ; Переносим текущий элемент первого массива в регистр BX
	mov ax,mas2[si] ; Переносим текущий элемент второго массива в регистр AX
	sub ax,bx 		; Запишем в регистр AX разность регистров AX и BX, то есть, текущей пары элементов
	mov mas1[si],ax ; Записываем получившуюся разность текущих элементов на место текущего элемента первого массива
	; Переходим к нахождению суммы следующей пары
	inc si
	inc si
; Пока SI (текущий индекс) меньше чем CX (Размер массивов), переходим к метке label_sub
loop label_sub
	ret ; Возвращаемся из фукнции 
sub_proc endp

; Процедура для деления элементов двух массивов с одинаковыми индексами
div_proc proc near
    mov si,0 ; Индекс текущего элемента массива
    mov cx,5 ; Число элементов в обоих массивах
;Метка для перехода
del:
    xor dx,dx 		; Обнуляем регистр DX
    mov bx,mas1[si] ; Переносим текущий элемент первого массива в регистр BX
    mov ax,mas2[si] ; Переносим текущий элемент второго массива в регистр AX
    div bl			; Запишем в регистр AL частное регистров AX и BL, то есть, текущей пары элементов
    mov dl,al 		; Переноси Результат из регистра AL в регистр DL
    mov mas1[si],dx ; Записываем получившееся частное текущих элементов на место текущего элемента первого массива
    ; Переходим к нахождению суммы следующей пары
	inc si
    inc si
; Пока SI (текущий индекс) меньше чем CX (Размер массивов), переходим к метке del
loop    del
    ret ; Возвращаемся из фукнции 
div_proc endp


; Процедура для перемножения элементов двух массивов с одинаковыми индексами
mul_proc proc near
	mov si,0 ; Индекс текущего элемента массива
	mov cx,5 ; Число элементов в обоих массивах
;Метка для перехода
label_mul:
	xor dx,dx 		; Обнуляем регистр DX
	mov bx,mas1[si] ; Переносим текущий элемент первого массива в регистр BX
	mov ax,mas2[si] ; Переносим текущий элемент второго массива в регистр AX
	mul bl 			; Запишем в регистр AX произведение регистров BL и AL, то есть, текущей пары элементов
	mov dx,ax 		; Переноси Результат из регистра AX в регистр DX
	mov mas1[si],dx ; Записываем получившееся произведение текущих элементов на место текущего элемента первого массива
	; Переходим к нахождению суммы следующей пары
	inc si
	inc si
; Пока SI (текущий индекс) меньше чем CX (Размер массивов), переходим к метке mul
loop label_mul
	ret ; Возвращаемся из фукнции 
mul_proc endp

; Процедура для вывода чисел из первого массива, 
; так как перевод чисел в символы этих чисел - наша забота
outp proc near
    mov si,0 ; Индекс текущего элемента массива
    mov cx,5 ; Число элементов в обоих массивах
; Метка для перехода
show:
    mov ax,mas1[si] ; Переносим текущий элемент первого массива в регистр AX
    mov dl,10 ; Запомним в регистре DL, что у нас десятичная система счисления
	; Запишем в регистр AL частное регистров AX и DL, 
	; а в AH - остаток от деления
	; Это необходимо, чтобы отделить один разряд от числа для вывода по одному символу
    div dl 
    mov tmp,ah ; Перенесём остаток от деления в переменную temp
    mov dl,al  ; Перенесём частное из регистра AL в регистр DL
	; Увеличиваем частное на это магическое число, 
	; чтобы получить номер символа ASCII кода 
    add dl,30h 
    mov ah,02h ; Запишем в регистр AH вектор, для вывода ASCII-код символа 
    int 21h ; Вызываем прерывание
    mov dl,tmp
    add dl,30h
    mov ah,02h
    int 21h
    inc si
    inc si
    mov ah,09h
    lea dx,abz
    int 21h
loop show
    ret
outp endp

; Процедура для вывода чисел из первого массива, 
; так как перевод чисел в символы этих чисел - наша забота
outp2 proc near
    mov si,0
    mov cx,5
show2:
    mov ax,mas2[si]
    mov dl,10
    div dl
    mov tmp,ah
    mov dl,al
    add dl,30h
    mov ah,02h
    int 21h
    mov dl,tmp
    add dl,30h
    mov ah,02h
    int 21h
    inc si
    inc si
    mov ah,09h
    lea dx,abz
    int 21h
loop show2
    ret
outp2 endp

; Начало программы
begin:
    call prep 	; Заполняем массивы числами
    call outp 	; Выводим первый массив на экран
    call outp2 	;Выводим второй массив на экраны
	
    mov  ah,09h 	; Указываем 9-ый вектор (Вывод строки, указываемой в регистре DX на экран)
    lea  dx,mes1 	; Вносим начало сообщения с результатами суммирования
    int  21h 		; Вызываем прерывание и вывод текста
    call add_proc 	; Суммируем элементы массивов
    call outp 		; Выводим результат, хранящийся в первом массиве
    call prep 		; Заново генирируем такой же первый массив
	
    mov ah,09h 		; Указываем 9-ый вектор (Вывод строки, указываемой в регистре DX на экран)
    lea  dx,mes2 	; Вносим начало сообщения с результатами вычитания
    int   21h 		; Вызываем прерывание и вывод текста
    call sub_proc 	; Вычитаем элементы массивов
    call outp 		; Выводим результат, хранящийся в первом массиве
    call prep 		; Заново генирируем такой же первый массив
	
    mov  ah,09h 	; Указываем 9-ый вектор (Вывод строки, указываемой в регистре DX на экран)
    lea  dx,mes3 	; Вносим начало сообщения с результатами перемножения
    int   21h 		; Вызываем прерывание и вывод текста
	call mul_proc 	; Перемножаем элементы массивов
	call outp 		; Выводим результат, хранящийся в первом массиве
	call prep 		; Заново генирируем такой же первый массив
	
	mov ah,09h 		; Указываем 9-ый вектор (Вывод строки, указываемой в регистре DX на экран)
	lea  dx,mes4 	; Вносим начало сообщения с результатами деления
	int  21h 		; Вызываем прерывание и вывод текста
	call div_proc 	; Делим элементы массивов
	call outp 		; Выводим результат, хранящийся в первом массиве
	
    mov  ax,4c00h  	; Указываем вектор для коррекного прекращения программы
    int  21h 		; прерываем программу  
code ends         

end begin ; Конец программы